/*
 * generated by Xtext
 */
package org.xtext.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.commonlang.Assignment;
import org.xtext.commonlang.BasicValueExpression;
import org.xtext.commonlang.Block;
import org.xtext.commonlang.BooleanValue;
import org.xtext.commonlang.CLfile;
import org.xtext.commonlang.CommonlangPackage;
import org.xtext.commonlang.Crement;
import org.xtext.commonlang.Declaration;
import org.xtext.commonlang.Else;
import org.xtext.commonlang.For;
import org.xtext.commonlang.If;
import org.xtext.commonlang.MetaMethod;
import org.xtext.commonlang.MetaMethodCall;
import org.xtext.commonlang.MetaMethods;
import org.xtext.commonlang.NegNumberValue;
import org.xtext.commonlang.NumberValue;
import org.xtext.commonlang.ParanValueExpression;
import org.xtext.commonlang.Return;
import org.xtext.commonlang.Script;
import org.xtext.commonlang.StringValue;
import org.xtext.commonlang.UserMethod;
import org.xtext.commonlang.UserMethodCall;
import org.xtext.commonlang.VarReference;
import org.xtext.commonlang.While;
import org.xtext.services.CommonlangGrammarAccess;

@SuppressWarnings("all")
public class CommonlangSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private CommonlangGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == CommonlangPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case CommonlangPackage.ASSIGNMENT:
				sequence_Assignment(context, (Assignment) semanticObject); 
				return; 
			case CommonlangPackage.BASIC_VALUE_EXPRESSION:
				sequence_BasicValueExpression(context, (BasicValueExpression) semanticObject); 
				return; 
			case CommonlangPackage.BLOCK:
				sequence_Block(context, (Block) semanticObject); 
				return; 
			case CommonlangPackage.BOOLEAN_VALUE:
				sequence_BooleanValue(context, (BooleanValue) semanticObject); 
				return; 
			case CommonlangPackage.CLFILE:
				sequence_CLfile(context, (CLfile) semanticObject); 
				return; 
			case CommonlangPackage.CREMENT:
				sequence_Crement(context, (Crement) semanticObject); 
				return; 
			case CommonlangPackage.DECLARATION:
				sequence_Declaration(context, (Declaration) semanticObject); 
				return; 
			case CommonlangPackage.ELSE:
				sequence_Else(context, (Else) semanticObject); 
				return; 
			case CommonlangPackage.FOR:
				sequence_For(context, (For) semanticObject); 
				return; 
			case CommonlangPackage.IF:
				sequence_If(context, (If) semanticObject); 
				return; 
			case CommonlangPackage.META_METHOD:
				sequence_MetaMethod(context, (MetaMethod) semanticObject); 
				return; 
			case CommonlangPackage.META_METHOD_CALL:
				if(context == grammarAccess.getCallRule() ||
				   context == grammarAccess.getExpressionRule() ||
				   context == grammarAccess.getSimpleExpressionRule() ||
				   context == grammarAccess.getValueRule()) {
					sequence_Call_MetaMethodCall(context, (MetaMethodCall) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getMetaMethodCallRule()) {
					sequence_MetaMethodCall(context, (MetaMethodCall) semanticObject); 
					return; 
				}
				else break;
			case CommonlangPackage.META_METHODS:
				sequence_MetaMethods(context, (MetaMethods) semanticObject); 
				return; 
			case CommonlangPackage.NEG_NUMBER_VALUE:
				sequence_NegNumberValue(context, (NegNumberValue) semanticObject); 
				return; 
			case CommonlangPackage.NUMBER_VALUE:
				sequence_NumberValue(context, (NumberValue) semanticObject); 
				return; 
			case CommonlangPackage.PARAN_VALUE_EXPRESSION:
				sequence_ParanValueExpression(context, (ParanValueExpression) semanticObject); 
				return; 
			case CommonlangPackage.RETURN:
				sequence_Return(context, (Return) semanticObject); 
				return; 
			case CommonlangPackage.SCRIPT:
				sequence_Script(context, (Script) semanticObject); 
				return; 
			case CommonlangPackage.STRING_VALUE:
				sequence_StringValue(context, (StringValue) semanticObject); 
				return; 
			case CommonlangPackage.USER_METHOD:
				sequence_UserMethod(context, (UserMethod) semanticObject); 
				return; 
			case CommonlangPackage.USER_METHOD_CALL:
				if(context == grammarAccess.getCallRule() ||
				   context == grammarAccess.getExpressionRule() ||
				   context == grammarAccess.getSimpleExpressionRule() ||
				   context == grammarAccess.getValueRule()) {
					sequence_Call_UserMethodCall(context, (UserMethodCall) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getUserMethodCallRule()) {
					sequence_UserMethodCall(context, (UserMethodCall) semanticObject); 
					return; 
				}
				else break;
			case CommonlangPackage.VAR_REFERENCE:
				sequence_VarReference(context, (VarReference) semanticObject); 
				return; 
			case CommonlangPackage.WHILE:
				sequence_While(context, (While) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     ((vari=VarReference | vari=Declaration) op=MathOperator? value=ValueExpression)
	 */
	protected void sequence_Assignment(EObject context, Assignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (varleft=Value ((op=MathOperator | op=BooleanOperator | op=ComparisonOperator) varright=ValueExpression)?)
	 */
	protected void sequence_BasicValueExpression(EObject context, BasicValueExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((exs+=SimpleExpression | exs+=StructureExpression)*)
	 */
	protected void sequence_Block(EObject context, Block semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (value='true' | value='false')
	 */
	protected void sequence_BooleanValue(EObject context, BooleanValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (scripts+=Script* mets=MetaMethods)
	 */
	protected void sequence_CLfile(EObject context, CLfile semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (method=[Method|CAPITALFIRST] parameters+=ValueExpression? parameters+=ValueExpression*)
	 */
	protected void sequence_Call_MetaMethodCall(EObject context, MetaMethodCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (method=[Method|LOWERFIRST] parameters+=ValueExpression? parameters+=ValueExpression*)
	 */
	protected void sequence_Call_UserMethodCall(EObject context, UserMethodCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (value=VarReference op=CrementOperator)
	 */
	protected void sequence_Crement(EObject context, Crement semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, CommonlangPackage.Literals.CREMENT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CommonlangPackage.Literals.CREMENT__VALUE));
			if(transientValues.isValueTransient(semanticObject, CommonlangPackage.Literals.CREMENT__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CommonlangPackage.Literals.CREMENT__OP));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getCrementAccess().getValueVarReferenceParserRuleCall_0_0(), semanticObject.getValue());
		feeder.accept(grammarAccess.getCrementAccess().getOpCrementOperatorParserRuleCall_1_0(), semanticObject.getOp());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (type=Datatype name=LOWERFIRST)
	 */
	protected void sequence_Declaration(EObject context, Declaration semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, CommonlangPackage.Literals.DECLARATION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CommonlangPackage.Literals.DECLARATION__TYPE));
			if(transientValues.isValueTransient(semanticObject, CommonlangPackage.Literals.DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CommonlangPackage.Literals.DECLARATION__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getDeclarationAccess().getTypeDatatypeParserRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getDeclarationAccess().getNameLOWERFIRSTTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     ex=Expression
	 */
	protected void sequence_Else(EObject context, Else semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, CommonlangPackage.Literals.ELSE__EX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CommonlangPackage.Literals.ELSE__EX));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getElseAccess().getExExpressionParserRuleCall_1_0(), semanticObject.getEx());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (init=SimpleExpression check=ValueExpression action=SimpleExpression bl=Block)
	 */
	protected void sequence_For(EObject context, For semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, CommonlangPackage.Literals.FOR__INIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CommonlangPackage.Literals.FOR__INIT));
			if(transientValues.isValueTransient(semanticObject, CommonlangPackage.Literals.FOR__CHECK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CommonlangPackage.Literals.FOR__CHECK));
			if(transientValues.isValueTransient(semanticObject, CommonlangPackage.Literals.FOR__ACTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CommonlangPackage.Literals.FOR__ACTION));
			if(transientValues.isValueTransient(semanticObject, CommonlangPackage.Literals.FOR__BL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CommonlangPackage.Literals.FOR__BL));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getForAccess().getInitSimpleExpressionParserRuleCall_2_0(), semanticObject.getInit());
		feeder.accept(grammarAccess.getForAccess().getCheckValueExpressionParserRuleCall_4_0(), semanticObject.getCheck());
		feeder.accept(grammarAccess.getForAccess().getActionSimpleExpressionParserRuleCall_6_0(), semanticObject.getAction());
		feeder.accept(grammarAccess.getForAccess().getBlBlockParserRuleCall_8_0(), semanticObject.getBl());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (ex=ValueExpression bl=Block el=Else?)
	 */
	protected void sequence_If(EObject context, If semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     method=[Method|CAPITALFIRST]
	 */
	protected void sequence_MetaMethodCall(EObject context, MetaMethodCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (type=Methodtype name=CAPITALFIRST parameters+=Declaration? parameters+=Declaration*)
	 */
	protected void sequence_MetaMethod(EObject context, MetaMethod semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (methods+=MetaMethod*)
	 */
	protected void sequence_MetaMethods(EObject context, MetaMethods semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (varleft=Value ((op=MathOperator | op=BooleanOperator | op=ComparisonOperator) varright=ValueExpression)?)
	 */
	protected void sequence_NegNumberValue(EObject context, NegNumberValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     value=INTSTRING
	 */
	protected void sequence_NumberValue(EObject context, NumberValue semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, CommonlangPackage.Literals.BASIC_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CommonlangPackage.Literals.BASIC_VALUE__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getNumberValueAccess().getValueINTSTRINGParserRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (ex=ValueExpression ((op=MathOperator | op=BooleanOperator | op=ComparisonOperator) varright=ValueExpression)?)
	 */
	protected void sequence_ParanValueExpression(EObject context, ParanValueExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     value=ValueExpression
	 */
	protected void sequence_Return(EObject context, Return semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, CommonlangPackage.Literals.RETURN__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CommonlangPackage.Literals.RETURN__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getReturnAccess().getValueValueExpressionParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         name=CAPITALFIRST 
	 *         (robottypes+=LOWERFIRST | robottypes+=CAPITALFIRST) 
	 *         (robotconfigs+=LOWERFIRST | robotconfigs+=CAPITALFIRST) 
	 *         ((robottypes+=LOWERFIRST | robottypes+=CAPITALFIRST) (robotconfigs+=LOWERFIRST | robotconfigs+=CAPITALFIRST))* 
	 *         methods+=UserMethod*
	 *     )
	 */
	protected void sequence_Script(EObject context, Script semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_StringValue(EObject context, StringValue semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, CommonlangPackage.Literals.BASIC_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CommonlangPackage.Literals.BASIC_VALUE__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getStringValueAccess().getValueSTRINGTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     method=[Method|LOWERFIRST]
	 */
	protected void sequence_UserMethodCall(EObject context, UserMethodCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (type=Methodtype name=LOWERFIRST parameters+=Declaration? parameters+=Declaration* bl=Block)
	 */
	protected void sequence_UserMethod(EObject context, UserMethod semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     vari=[Declaration|LOWERFIRST]
	 */
	protected void sequence_VarReference(EObject context, VarReference semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, CommonlangPackage.Literals.VAR_REFERENCE__VARI) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CommonlangPackage.Literals.VAR_REFERENCE__VARI));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getVarReferenceAccess().getVariDeclarationLOWERFIRSTTerminalRuleCall_0_1(), semanticObject.getVari());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (ex=ValueExpression bl=Block)
	 */
	protected void sequence_While(EObject context, While semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, CommonlangPackage.Literals.WHILE__EX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CommonlangPackage.Literals.WHILE__EX));
			if(transientValues.isValueTransient(semanticObject, CommonlangPackage.Literals.WHILE__BL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CommonlangPackage.Literals.WHILE__BL));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getWhileAccess().getExValueExpressionParserRuleCall_2_0(), semanticObject.getEx());
		feeder.accept(grammarAccess.getWhileAccess().getBlBlockParserRuleCall_4_0(), semanticObject.getBl());
		feeder.finish();
	}
}
