/*
 * generated by Xtext
 */
package org.xtext.validation

import org.eclipse.xtext.validation.Check
import org.xtext.commonlang.Call
import org.xtext.commonlang.VarReference
import org.xtext.commonlang.StringValue
import org.xtext.commonlang.NumberValue
import org.xtext.commonlang.BooleanValue
import org.xtext.commonlang.Value
import org.xtext.commonlang.Assignment
import org.xtext.commonlang.ValueExpression
import org.xtext.commonlang.Crement
import org.xtext.commonlang.If
import org.xtext.commonlang.While
import org.xtext.commonlang.For
import org.xtext.commonlang.ParanValueExpression
import org.xtext.commonlang.BasicValueExpression
import org.xtext.commonlang.Declaration
import org.xtext.commonlang.Method
import org.xtext.commonlang.UserMethod
import org.xtext.commonlang.Return
import org.xtext.commonlang.Expression
import org.xtext.commonlang.Block
import org.xtext.commonlang.CommonlangPackage.Literals
import org.xtext.commonlang.NegNumberValue

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class CommonlangValidator extends AbstractCommonlangValidator {

	@Check
	def checkCallParametersMatch(Call call) {
		if (call.getParameters().size() != call.getMethod().getParameters().size()) {
			error("Wrong number of arguments!",null)
		} else {
			for (var i = 0; i < call.getParameters().size(); i++) {
				var thisParam = call.getParameters().get(i)
				var thatType = call.getMethod().getParameters().get(i).getType();
				var thisType = getTypeOfValueExpression(thisParam)
				
				if (thisType != thatType) {
					error("Type mismatch: Expected "+ thatType +" got " + thisType,null)
				}
			}
		}
	}
	
	@Check
	def checkAssignments(Assignment assignment) {
		var thisType = assignment.value.getTypeOfValueExpression
		var ref = assignment.vari
		var thatType = ""
		
		switch ref {
			VarReference : thatType = ref.vari.type
			Declaration : {	thatType = ref.type
							if (assignment.op != null) {
								error("Cannot perform mathematical operation on new variable",null)
						  	}
					  	}
		}
		
		if (thisType != thatType) {
			error("Type mismatch: Expected "+ thatType +" got " + thisType,null)
		}
		
		if (assignment.op != null) {
			 if (thisType != 'int') {
				error("Invalid operation for type "+thisType,null)
			}
		}		
	}
	
	@Check
	def checkIf(If ifEx) {
		var extype = ifEx.ex.getTypeOfValueExpression
		if (extype != 'boolean') {
			error("Expected boolean expression",null)
		}
	}
	@Check
	def checkWhile(While whileEx) {
		var extype = whileEx.ex.getTypeOfValueExpression
		if (extype != 'boolean') {
			error("Expected boolean expression",null)
		}
	}
	@Check
	def checkFor(For forEx) {
		var extype = forEx.check.getTypeOfValueExpression
		if (extype != 'boolean') {
			error("Expected boolean expression",null)
		}
	}

	
	@Check
	def checkCrement(Crement crem) {
		var thisType = crem.value.getTypeOfValue
		if (thisType != 'int') {
			error("Invalid type: Cannot perform "+crem.op+" operation on "+thisType,null)
		}
	}
	
	@Check
	def checkParanValueExpression(ParanValueExpression valExp) {
		var thisType = valExp.ex.getTypeOfValueExpression
		valueExpressions(thisType,valExp);
	}
	
	@Check
	def checkBasicValueExpression(BasicValueExpression valExp) {
		var thisType = valExp.varleft.getTypeOfValue
		valueExpressions(thisType,valExp);
	}
	
	def valueExpressions(String thisType, ValueExpression valExp) {
		var thatType = "null"
		if (valExp.varright != null) {
			thatType = valExp.varright.getTypeOfValueExpression
		}
		
		if (valExp.op != null) {
			if (thisType != thatType) {
				error("Type mismatch: Cannot perform "+valExp.op+" on "+thisType+" and "+thatType,null)
			}
			
			if (valExp.op.isComparison) {
				if (valExp.op.isSizeComparison) {
					if (thisType != 'int' || thatType != 'int') {
						error("Cannot compare sizes of "+thisType+" and "+thatType,null)
					}
				}
				if (valExp.varright.op != null) {
					if (valExp.varright.op.isComparison) {
						error("Cannot string together comparisons",null)
					}
				}				
			} else if (valExp.op.isMath && (thisType != 'int' || thatType != 'int')) {
					error("Operator "+valExp.op+" is invalid for types "+thisType+" and "+thatType,null)
			}
		}
	}
	
	@Check
	def checkMethodReturn(UserMethod method) {
		var type = method.type;
		var block = method.bl;
		
		if (type != "void") {
			if (!block.returnsValue(type)) {
				error("Method has return type "+type+" but may not return a valid value",null)
			}
		}
	}
	
	def boolean returnsValue(Expression ex, String type) {
		switch (ex) {
			Block : {
						var returns = false;
						for (x : ex.exs) {
							if (returns == true) {
								warning("Code after a return statement",null)
							}
							if (x.returnsValue(type)) {
								returns = true;
							}
						}
						return returns;
					}
			If : 
					if (ex.el != null) {
						return ex.bl.returnsValue(type) && ex.el.ex.returnsValue(type)
					} else {
						return false
					}
			Return : if (type == ex.value.getTypeOfValueExpression) {			
						return true
					} else {
						error("Must return value of type "+type,null)
						return true
					}
			default : return false
		}
	}
	
	def String getTypeOfValueExpression(ValueExpression thisVal) {
		var type ="null"
		switch(thisVal){
			ParanValueExpression : type = thisVal.ex.getTypeOfValueExpression
			BasicValueExpression : type = thisVal.varleft.getTypeOfValue
		}
		
		if (thisVal.op != null) {
			if (thisVal.op.isComparison) {
				if (type == thisVal.varright.getTypeOfValueExpression) {
					type = 'boolean';
				}
			}
		}
		return type
	}
	
	def String getTypeOfValue(Value thisVal) {
		var thisType = "";
		switch (thisVal) {
			Call : thisType = thisVal.method.type
			VarReference : thisType = thisVal.vari.type
			NumberValue : thisType = "int"
			NegNumberValue : thisType = "int"
			StringValue : thisType = "string"
			BooleanValue : thisType = "boolean"
		}
		return thisType
	}
	
	def String[] getMetaMethodParamList(String name) {
		switch (name) {
			case 'Idle',
			case 'TurnLeft',
			case 'TurnRight',
			case 'MoveForward',
			case 'MoveBackward' : return #["int"]
			default : return #[]
		}
	}
	
	def isComparison(String operator) {
		switch(operator) {
			case "!=",
			case "==" : return true
		}
		
		return isSizeComparison(operator)
	}
	
	def isSizeComparison(String operator) {
		switch(operator) {
			case "<",
			case ">",
			case "<=",
			case ">=" : return true
		}
		return false
	}
	
	def isMath(String operator) {
		switch (operator) {
			case '+',
			case '-',
			case '*',
			case '/' : return true
		}
		return false
	}
	
	
//  public static val INVALID_NAME = 'invalidName'
//
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital', 
//					MyDslPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}
}
