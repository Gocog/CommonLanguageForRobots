/*
 * generated by Xtext
 */
package org.xtext.validation

import org.eclipse.xtext.validation.Check
import org.xtext.commonlang.Call
import org.xtext.commonlang.VarReference
import org.xtext.commonlang.StringValue
import org.xtext.commonlang.NumberValue
import org.xtext.commonlang.BooleanValue
import org.xtext.commonlang.Value
import org.xtext.commonlang.Assignment
import org.xtext.commonlang.ValueExpression
import org.xtext.commonlang.Crement
import org.xtext.commonlang.If
import org.xtext.commonlang.While
import org.xtext.commonlang.For
import org.xtext.commonlang.ParanValueExpression
import org.xtext.commonlang.BasicValueExpression

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class CommonlangValidator extends AbstractCommonlangValidator {

	@Check
	def checkCallParametersMatch(Call call) {
		if (call.getParameters().size() != call.getMethod().getParameters().size()) {
			error("Wrong number of arguments!",null)
		} else {
			for (var i = 0; i < call.getParameters().size(); i++) {
				var thisParam = call.getParameters().get(i)
				var thatType = call.getMethod().getParameters().get(i).getType();
				var thisType = getTypeOfValueExpression(thisParam)
				
				if (thisType != thatType) {
					error("Type mismatch: Expected "+ thatType +" got " + thisType,null)
				}
			}
		}
	}
	
	@Check
	def checkAssignments(Assignment assignment) {
		var thisType = assignment.value.getTypeOfValueExpression
		var thatType = assignment.vari.getType();
		
		if (thisType != thatType) {
			error("Type mismatch: Expected "+ thatType +" got " + thisType,null)
		}
	}
	
	@Check
	def checkIf(If ifEx) {
		var extype = ifEx.ex.getTypeOfValueExpression
		if (extype != 'boolean') {
			error("Expected boolean expression",null)
		}
	}
	@Check
	def checkWhile(While whileEx) {
		var extype = whileEx.ex.getTypeOfValueExpression
		if (extype != 'boolean') {
			error("Expected boolean expression",null)
		}
	}
	@Check
	def checkFor(For forEx) {
		var extype = forEx.check.getTypeOfValueExpression
		if (extype != 'boolean') {
			error("Expected boolean expression",null)
		}
	}

	
	@Check
	def checkCrement(Crement crem) {
		var thisType = crem.value.getTypeOfValue
		if (thisType != 'int') {
			error("Invalid type: Cannot perform "+crem.op+" operation on "+thisType,null)
		}
	}
	
	@Check
	def checkParanValueExpression(ParanValueExpression valExp) {
		var thisType = valExp.ex.getTypeOfValueExpression
		var thatType = "null"
		if (valExp.varright != null) {
			thatType = valExp.varright.getTypeOfValueExpression
		}
		
		if (valExp.op != null) {
			if (thisType != thatType) {
				error("Type mismatch: Cannot perform "+valExp.op+" on "+thisType+" and "+thatType,null)
			}
			
			if (valExp.op.isComparison) {
				if (valExp.op.isSizeComparison) {
					if (thisType != 'int' || thatType != 'int') {
						error("Cannot compare sizes of "+thisType+" and "+thatType,null)
					}
				}
				if (valExp.varright.op != null) {
					if (valExp.varright.op.isComparison) {
						error("Cannot string together comparisons",null)
					}
				}				
			}
		}
	}
	
	@Check
	def checkBasicValueExpression(BasicValueExpression valExp) {
		var thisType = valExp.varleft.getTypeOfValue
		var thatType = "null"
		if (valExp.varright != null) {
			thatType = valExp.varright.getTypeOfValueExpression
		}
		
		if (valExp.op != null) {
			if (thisType != thatType) {
				error("Type mismatch: Cannot perform "+valExp.op+" on "+thisType+" and "+thatType,null)
			}
			
			if (valExp.op.isComparison) {
				if (valExp.op.isSizeComparison) {
					if (thisType != 'int' || thatType != 'int') {
						error("Cannot compare sizes of "+thisType+" and "+thatType,null)
					}
				}
				if (valExp.varright.op != null) {
					if (valExp.varright.op.isComparison) {
						error("Cannot string together comparisons",null)
					}
				}				
			}
		}
	}
	
	def String getTypeOfValueExpression(ValueExpression thisVal) {
		var type ="null"
		switch(thisVal){
			ParanValueExpression : type = thisVal.ex.getTypeOfValueExpression
			BasicValueExpression : type = thisVal.varleft.getTypeOfValue
		}
		
		if (thisVal.op != null) {
			if (thisVal.op.isComparison) {
				if (type == thisVal.varright.getTypeOfValueExpression) {
					type = 'boolean';
				}
			}
		}

		return type
	}
	
	def String getTypeOfValue(Value thisVal) {
		var thisType = "";
		switch (thisVal) {
			Call : thisType = thisVal.method.type
			VarReference : thisType = thisVal.vari.type
			NumberValue : thisType = "int"
			StringValue : thisType = "string"
			BooleanValue : thisType = "boolean"
		}
		return thisType
	}
	
	def String[] getMetaMethodParamList(String name) {
		switch (name) {
			case 'Idle',
			case 'TurnLeft',
			case 'TurnRight',
			case 'MoveForward',
			case 'MoveBackward' : return #["int"]
			default : return #[]
		}
	}
	
	def isComparison(String operator) {
		switch(operator) {
			case "!=",
			case "==" : return true
		}
		
		return isSizeComparison(operator)
	}
	
	def isSizeComparison(String operator) {
		switch(operator) {
			case "<",
			case ">",
			case "<=",
			case ">=" : return true
		}
		return false
	}
	
	
//  public static val INVALID_NAME = 'invalidName'
//
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital', 
//					MyDslPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}
}
